# -*- coding: utf-8 -*-
# This file is part of Dyko
# Copyright Â© 2008-2009 Kozea
#
# This library is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Kalamar.  If not, see <http://www.gnu.org/licenses/>.

"""
Base classes to create kalamar items.

You probably want to use the Item.get_item_parser method to get the parser you
need. You may also want to inherit from one of the followings so you can write
your own parsers:
- CapsuleItem
- AtomItem

Any item parser class has to have a static attribute "format" set to the format
parsed, otherwise this class will be hidden to get_item_parser.

A parser class must implement the following methods:
- _custom_parse_data(self)
- _serialize(self, properties)

It must have a class attribute "format" which is name of the parsed format.

"""

from kalamar import parser, utils
from copy import copy
from werkzeug import MultiDict

class Item(object):
    """
    Abstract class, base of any item parser.
    
    You can use the Item.get_item_parser static method to get automatically the
    parser you want.

    Useful attributes:
    - properties: acts like a defaultdict. The keys are strings and the values
      are MultiDict of python objects with default value at None.
    - _access_point: where, in kalamar, is stored the item. It is an instance
      of AccessPoint.

    This class is abstract and used by AtomItem and CapsuleItem, which are
    inherited by the parsers.

    """
    
    format = None

    def __init__(self, access_point, opener, accessor_properties={}):
        """Return an instance of Item.
        
        Parameters:
        - access_point: an instance of the AccessPoint class.
        - opener: a function taking no parameters and returning file-like
          object.
        - accessor_properties: properties generated by the accessor for this
          item.
        
        """
        self._opener = opener
        self._stream = None
        self.properties = ItemProperties(self, accessor_properties)
        self._access_point = access_point
        self.aliases = dict(self._access_point.parser_aliases)
        self.aliases.update(self._access_point.storage_aliases)
        self.aliases_rev = dict((b,a) for (a,b) in enumerate(self.aliases))
    
    @staticmethod
    def get_item_parser(format, *args, **kwargs):
        """Return an appropriate parser instance for the given format.
        
        Your kalamar distribution should have, at least, a paser for the
        "binary format".
        
        >>> from _test.corks import CorkAccessPoint, cork_opener
        >>> ap = CorkAccessPoint()
        >>> Item.get_item_parser("binary", ap, cork_opener, {"artist": "muse"})
        ...  # doctest: +ELLIPSIS
        <kalamar.parser.binaryitem.BinaryItem object at ...>
        
        An invalid format will raise a ValueError:
        >>> Item.get_item_parser("I do not exist", ap, cork_opener)
        Traceback (most recent call last):
        ...
        ValueError: Unknown format: I do not exist
        
        """

        parser.load()

        for subclass in utils.recursive_subclasses(Item):
            if getattr(subclass, 'format', None) == format:
                return subclass(*args, **kwargs)
        
        raise ValueError('Unknown format: ' + format)

    @property
    def encoding(self):
        """Return the item's encoding.

        Return the item's encoding, based on what the parser can know from
        the items's data or, if unable to do so, on what is specified in the
        access_point.

        """
        return self._access_point.default_encoding

    def serialize(self):
        """Return the item serialized into a string."""
        # Remove aliases
        properties = dict((self.aliases.get(key,key), self.properties[key])
                     for key in self.properties.keys())
        return _serialize(self, properties)
    
    def _custom_serialize(self, properties):
        """Serialize item from its properties, return a data string.

        **This method have to be overriden.**

        This method must not worry about aliases, must not modify "properties",
        and must just return a string.

        """
        raise NotImplementedError("Abstract class")
    
    def _parse_data(self):
        """Call "_custom_parse_data" and do some stuff to the result."""

        self._open()
        properties = self._custom_parse_data()
        self.properties.update(properties)

    def _custom_parse_data(self):
        """Parse properties from data, return a dictionnary.
        
        **This method have to be overriden.**

        This method must not worry about aliases, must not modify "properties",
        and must just return a dict.

        """
        raise NotImplementedError("Abstract method")
    
    def _open(self):
        """Open the stream when called for the first time.
        
        >>> from _test.corks import CorkAccessPoint, cork_opener
        >>> ap = CorkAccessPoint()
        >>> item = Item(ap, cork_opener, {'toto': 'ToTo'})
        
        >>> item._stream
        >>> item._open()
        >>> stream = item._stream
        >>> print stream # doctest: +ELLIPSIS
        <open file '...kalamar/_test/toto', mode 'r' at ...>
        >>> item._open()
        >>> stream is item._stream
        True
        
        """
        if self._stream is None:
            self._stream = self._opener()

class AtomItem(Item):
    """An indivisible block of data.
    
    This is an abstract class.
    
    """
    def read(self):
        """Alias for properties["_content"]."""
        return self.properties["_content"]

    def write(self, value):
        """Alias for properties["_content"] = value."""
        self.properties["_content"] = value

class CapsuleItem(Item, list):
    """An ordered list of Items (atoms or capsules)

    This is an abstract class.

    """
    pass

class ItemProperties(MultiDict):
    """MultiDict with a default value, used as a properties storage.

    You have to give a reference to the item to the constructor. You can force
    some properties to a value giving a dictionnary as "storage_properties"
    argument.
    
    >>> from _test.corks import CorkItem
    >>> item = CorkItem({'a': 'A', 'b': 'B'})
    >>> prop = item.properties
    
    ItemProperties works as a dictionnary:
    >>> prop['cork_prop']
    'I am a cork prop'
    
    But it can contais multiple values:
    >>> prop.getlist('cork_prop')
    ['I am a cork prop', 'toto', 'tata']
    
    This key has been forced with "storage_properties":
    >>> prop['b']
    'B'
    
    You can modifie content and know if the item's data has been modified:
    >>> prop.parser_content_modified
    False
    >>> prop['cork_prop'] = 'new value'
    >>> prop['cork_prop']
    'new value'
    >>> prop.parser_content_modified
    True
    
    Storage properties can be accessed separately by a dictionnary:
    >>> prop.storage_properties
    {'a': 'A', 'b': 'B'}
    
    If a storage property has been changed, the old value is still reachable:
    >>> prop['b'] = 'toto'
    >>> prop.storage_properties_old
    {'a': 'A', 'b': 'B'}
    
    But the original value is not changed:
    >>> super(ItemProperties, prop).__getitem__('b')
    "item's b"
    
    Return None if the key does not exist:
    >>> prop['I do not exist']
    
    CorkItem has an alias "I am aliased" -> "I am not aliased":
    >>> prop['I am aliased']
    'value of: I am not aliased'
    >>> prop['I am not aliased']
    'value of: I am not aliased'

    """
    
    def __init__(self, item, storage_properties={}):
        """Load item properties.

        The "storage_properties" argument is a dictionnary used to set default
        values for some properties.

        For performance purpose, note that the load is lazy: calling this
        function does not really load the item in memory.
        """
        # Up-to-date properties
        self.storage_properties = storage_properties
        # Properties set before last synchronizing on storage
        self.storage_properties_old = copy(storage_properties)
        self.parser_content_modified = False

        # Internal values set for lazy load
        self._item = item
        self._loaded = False

    def __getitem__(self, key):
        """Return the item's "key" property."""
        # Lazy load: load item only if needed
        if not self._loaded:
            self._item._parse_data()
            self._loaded = True
        # Aliasing
        key = self._item.aliases.get(key, key)
        if key in self.storage_properties.keys():
            return self.storage_properties[key]
        else:
            try:
                return super(ItemProperties, self).__getitem__(key)
            except KeyError:
                return None
    
    def __setitem__(self, key, value):
        """Set the item's "key" property to "value"."""
        # Aliasing
        key = self._item.aliases.get(key, key)
        if key in self.storage_properties.keys():
            self.storage_properties[key] = value
        else:
            super(ItemProperties, self).__setitem__(key, value)
            self.parser_content_modified = True
